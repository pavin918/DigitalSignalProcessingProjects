#include "dsk6713_aic23.h"
#include "dsk6713_led.h"
#define DSK6713_AIC23_INPUT_MIC 0x0015
#define DSK6713_AIC23_INPUT_LINEIN 0x0011

Uint32 fs = DSK6713_AIC23_FREQ_16KHZ; // 1
Uint16 inputsource = DSK6713_AIC23_INPUT_LINEIN; // 0x011
unsigned int i = 0;
const int SIZE = 51;

// Problem 2 Finite Impulse Response high-pass filter
float hpf_fir [51] =
{-0.000719150312854400,0.000935044661893439,0.000442110331584869,-0.00160958733
367831,0.000194981511618248,0.00253681043743606,-0.00174280100983270,-0.0031764
3317418914,0.00453858851009697,0.00251649791536997,-0.00832597506970928,0.00064
6873892044080,0.0119995565631141,-0.00725858432270368,-0.0135714877449711,0.017
5396463194574,0.0103202148713842,-0.0306917093286511,0.00118828929073415,0.0449
096811805753,-0.0263224722820524,-0.0577381744168883,0.0810056320484234,0.06668
33063922820,-0.309043289229996,0.429341650509185,-0.309043289229996,0.066683306
3922820,0.0810056320484234,-0.0577381744168883,-0.0263224722820524,0.0449096811
805753,0.00118828929073415,-0.0306917093286511,0.0103202148713842,0.01753964631
94574,-0.0135714877449711,-0.00725858432270368,0.0119995565631141,0.00064687389
2044080,-0.00832597506970928,0.00251649791536997,0.00453858851009697,-0.0031764
3317418914,-0.00174280100983270,0.00253681043743606,0.000194981511618248,-0.001
60958733367831,0.000442110331584869,0.000935044661893439,-0.000719150312854400
};

void main() {
	comm_poll();
	float y;
	short buffer[SIZE];
	for(i = 0; i < SIZE; i++) {
		buffer[i] = input_left_sample();
	}
	while(1) {
		y = 0;
		for (i = 0; i < SIZE; i++)
			y += hpf_fir[i] * buffer[SIZE - i - 1];
		for (i = 0; i < SIZE - 1; i++)
			buffer[i] = buffer[i + 1];
		buffer[SIZE - 1] = input_left_sample();
		output_left_sample((short)y);
	}
}

//Problem 3 Finite Impulse Response band-pass filter

/*
float bpf_fir[SIZE] =
{0.00173804038433836,-0.0000818329982388869,-0.000197757394302796,0.00082888573
9262472,-0.00212364071389786,-0.00507905032265195,-0.0000918030243035165,0.0037
2654819024800,-0.000538963539585851,0.00431061666171047,0.0151620016893806,0.00
191720239813089,-0.0173385080693537,-0.00638126960350276,-0.00395696633047738,-
0.0303153520677700,-0.00869784943549450,0.0521362171617645,0.0363829432014739,-
0.00576742902759117,0.0442866897719188,0.0301851411190233,-0.171026242646072,-0.
220759943321729,0.107305119874599,0.349838107144798,0.107305119874599,-0.220759
943321729,-0.171026242646072,0.0301851411190233,0.0442866897719188,-0.005767429
02759117,0.0363829432014739,0.0521362171617645,-0.00869784943549450,-0.03031535
20677700,-0.00395696633047738,-0.00638126960350276,-0.0173385080693537,0.001917
20239813089,0.0151620016893806,0.00431061666171047,-0.000538963539585851,0.0037
2654819024800,-0.0000918030243035165,-0.00507905032265195,-0.00212364071389786,
0.000828885739262472,-0.000197757394302796,-0.0000818329982388869,0.00173804038
433836};

void main() {
	comm_poll();
	float y;
	short buffer[SIZE];
	for(i = 0; i < SIZE; i++){
		buffer[i] = input_left_sample();
	}
	while(1){
		y = 0;
		for (i = 0; i < SIZE; i++)
			y += bpf_fir[i] * buffer[SIZE - i - 1];
		for (i = 0; i < SIZE - 1; i++)
			buffer[i] = buffer[i + 1];
		buffer[SIZE - 1] = input_left_sample();
		output_left_sample((short)y);
	}
}
*/

//Problem 4 Infinite Impulse Response low-pass filter

/*
const int FILTER_LEN = 11;

float lpf_iir_b[FILTER_LEN] =
{0.0152550224105746,-0.0493796754291947,0.0961854954970261,-0.118723890386639,0.
122312552889201,-0.114107264166309,0.122312552889201,-0.118723890386639,0.09618
54954970260,-0.0493796754291946,0.0152550224105746};

float lpf_iir_a[11] =
{1,-5.29478690795677,13.3830271120091,-20.8604390248056,22.0409073555607,-16.3997
573159628,8.67332019492232,-3.20904788995105,0.794102467286104,-0.1183998580049
64,0.00826561269860652};

void main() {
	comm_poll();
	char i;
	short x[FILTER_LEN];
	double y[FILTER_LEN];
	double temp;
	// Initialize buffer to 0
	for (i = 0; i < FILTER_LEN; i++) {
		x[i] = 0;
	}
	for (i = 0; i < FILTER_LEN; i++) {
		y[i] = 0.0;
	}
	while(1) {
		for (i = FILTER_LEN-1; i > 0; i--) {
			x[i] = x[i-1];
		}
		for (i=FILTER_LEN-1; i > 0; i--) {
			y[i] = y[i-1];
		}
		temp = 0;
		x[0] = input_left_sample();
		for (i = 0; i < FILTER_LEN; i++) {
			temp += lpf_iir_b[i] * x[i];
		}
		y[0] = temp; //* lpf_iir_a[0];
		for (i = 1; i < FILTER_LEN; i++) {
			y[0] -= lpf_iir_a[i] * y[i];
		}
		y[0] = y[0] * (1 / lpf_iir_a[0]);
		output_left_sample((short) y[0]);
	}
}
*/

//Problem 5 Infinite Impulse Response high-pass filter

/*
const int FILTER_LEN = 11;

double hpf_iir_b[FILTER_LEN] =
{0.000884577085863563,-0.00884577085863563,0.0398059688638604,-0.10614925030362
8,0.185761188031348,-0.222913425637618,0.185761188031348,-0.106149250303628,0.03
98059688638604,-0.00884577085863563,0.000884577085863563};

double hpf_iir_a[FILTER_LEN] =
{1,1.39450010493605,2.16234423909640,1.68974273396699,1.21840264081444,0.5629925
42767413,0.219023203137815,0.0564306293019384,0.0108463384415639,0.00121020224
486195,.0000667276513233946};

void main() {
	comm_poll();
	char i;
	short x[FILTER_LEN];
	double y[FILTER_LEN];
	double temp;
	// Initialize buffer to 0
	for (i = 0; i < FILTER_LEN; i++) {
		x[i] = 0;
	}
	for (i = 0; i < FILTER_LEN; i++) {
		y[i] = 0.0;
	}
	while(1) {
		for (i = FILTER_LEN-1; i > 0; i--) {
			x[i] = x[i-1];
		}
		for (i=FILTER_LEN-1; i > 0; i--) {
			y[i] = y[i-1];
		}
		temp = 0;
		x[0] = input_left_sample();
		for (i = 0; i < FILTER_LEN; i++) {
			temp += hpf_iir_b[i] * x[i];
		}
		y[0] = temp;;
		for (i = 1; i < FILTER_LEN; i++) {
			y[0] -= hpf_iir_a[i] * y[i];
		}
		y[0] = y[0] * (1 / hpf_iir_a[0]);
		output_left_sample((short) y[0]);
	}
}
*/

//Problem 6 Infinite Impulse Response band-pass filter

/*
const int FILTER_LEN = 21;
float bpf_iir_b[FILTER_LEN ] =
{0.000172383740191716,0,-0.00172383740191716,0,0.00775726830862722,0,-0.02068604
88230059,0,0.0362005854402604,0,-0.0434407025283125,0,0.0362005854402604,0,-0.020
6860488230059,0,0.00775726830862722,0,-0.00172383740191716,0,0.0001723837401917
16};

float bpf_iir_a[FILTER_LEN ] =
{1,-4.93471074974774,14.1071880704920,-29.1603297837713,48.5049851195987,-67.6571
897465564,81.3524732995103,-85.4971760627105,79.4338163377995,-65.5479269717378,
48.2158693435008,-31.5906305154249,18.4154149449824,-9.49463155136709,4.30164217
159637,-1.68906061357564,0.566167259814615,-0.156857675539605,0.034604323689757
8,-0.00546758351163364,0.000532881341674807};

void main() {
	comm_poll();
	char i;
	short x[FILTER_LEN];
	double y[FILTER_LEN];
	double temp;
	// Initialize buffer to 0
	for (i = 0; i < FILTER_LEN; i++) {
		x[i] = 0;
	}
	for (i = 0; i < FILTER_LEN; i++) {
		y[i] = 0.0;
	}
	while(1) {
		for (i = FILTER_LEN-1; i > 0; i--) {
			x[i] = x[i-1];
		}
		for (i=FILTER_LEN-1; i > 0; i--) {
			y[i] = y[i-1];
		}
		temp = 0;
		x[0] = input_left_sample();
		for (i = 0; i < FILTER_LEN; i++) {
			temp += bpf_iir_b[i] * x[i];
		}
		y[0] = temp;
		for (i = 1; i < FILTER_LEN; i++) {
			y[0] -= bpf_iir_a[i] * y[i];
		}
		y[0] = y[0] * (1 / bpf_iir_a[0]);
		output_left_sample((short) y[0]);
	}
}
*/